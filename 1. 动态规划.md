[TOC]

##### 什么是背包问题？

背包问题的一个核心观念是：对于某个物品，拿or不拿？以此对其之后的结果产生连锁影响。

从这个角度说的话，其实分割问题并不是背包问题，而更像是一类可以用动态规划解决的问题。

# 纯动态规划

这里收集的是一些不太与背包问题产生联系的动态规划问题

- 分割问题（子串，子数组，数值划分以此产生的某种性质）
- 子序列问题
- 股票交易问题

### 一、分割问题

**dp[i]的常用含义，尤其是在分割类型（子字符串，子数组，子序列，分割数字等）的问题中：以i为结尾的子字符串/子数组/子序列的...**

在某些取极值问题中，需要实时更新result最大值：

```c++
for(int i=1;i<nums.size();i++){
	.............
    result = result>dp[i]? result:dp[i];
}
```

#### 1.1 子串问题

##### [139] 单词拆分

可重复，是否能凑成target （true or false问题）

给定一个字符串s和一个单词词典vector<string> wordDict，求s是否全部可以用wordDict中的单词拼接成

- 能够想到用动态规划解决，并合理设置出dp数组的含义与递推表达式
- 对下标i,j的处理

##### [5] 最长回文子串

给定字符串s，返回其最长回文子串`string`

**分析**

在子串/数组/数字的分割问题中，始终以0为起始点的问题可以被归结为背包问题。（不是）

例如在“连续子数组的最大和”问题中，dp[i]表示以i为结尾的所有子数组的最大和，它是可以被dp[i-1]的值推导出来的。

在之前遇到的子串动态规划题目中，例如 139. 单词划分，dp[i]表示[0,i]范围内的子串能否被wordDict中的单词表示，我们发现只要 dp[j]==true 且 [j+1,i]的子串在wordDict中，那么dp[i]=true,反之=false。

如果我们在本题中继续沿用之前的思想，dp[i]代表以i为结尾的所有回文子串的最大长度，那么对于dp[i]与dp[i-1]，我们并不能写出一个严格正确的递推表达式。

**对于回文子串类的问题，我们首先想到使用动态规划来解决。其中，$dp[i][j]$​​表示字符串下标从[i,j]的子字符串……（是否是回文串/最长回文子序列的长度等等，依据题目的要求进行设定）。**

题目要求得到string类型的结果，这显然是不能递推的。我们这时可以尝试一下“惯用套路”，即设$dp[i][j]$​表示[i,j]的字符串是否为回文，为了得到这个字符串，可以定义一个变量，保存$dp[i][j]$为true时，最大的j-i+1值的（i,j）

##### [647] 回文子串

给定一个字符串，求其回文子串的数量。

**分析**

在动态规划的题目中，依照答案的给出方式，分为两类题目。

一类题目是dp数组的含义完全按照问题来设定，这样的题目最终结果一般由dp数组中的某个元素直接给出。例如$dp[nums.size()-1]$​。

第二类题目是dp数组的含义并不完全按照问题设定，而是使用了一个与其相近的题目背景来进行设定。其原因往往是因为按照其题目设定的dp数组无法写出递推公式。这样的题目结果往往需要一个辅助性的变量来负责结果的计算。

在这道题目中，最直接的想法是将$dp[i][j]$​​设定为[i,j]子串内的回文子串数量，但是经过**一番尝试**后发现写不出递推公式。

```c++
①假设字符串从“bcd”→“abcde”
两端的字符不相等，则dp[i][j]=dp[i+1][j-1]+2;
②假设字符串从“bac”→“abace”
两端的字符不相等，但此时dp并不能简单的＋2。由于另一个a的加入导致形成了新的回文字符串。此时我们发现递推公式已经没办法写了。
```

我们尝试换一种思路，即前面题目所用到的$dp[i][j]$表示[i,j]的字符串是否是回文。我们只需要额外定义一个变量记录其为“true”的个数即可。

此时我们的递推公式与前面相同

```c++
if(s[i]==s[j]){
	if(j-i<=1){
		dp[i][j]==true;
        result++;
	}
	else{
		if(dp[i+1][j-1]){
			dp[i][j]=true;
            result++;
		}
	}
}
//当s[i]!=s[j]时，dp[i][j]为false,由于数组初始值设定就是false，因此这里do nothing
```

如何计算数量呢？很简单，只需要在每个$dp[i][j]$​为true的地方`result++`就好了。

初始值与遍历顺序：

初始值设为全false，递推公式用到了$dp[i+1][j-1]$,因此遍历顺序为i从大到小，j从小到大，另外j>=i

```c++
for(int i=size-1;i>=0;--i){
	for(int j=i;j<size;j++){}
}
```

由于dp数组的推导涉及到了$dp[i+1][j-1]$,我一开始对i和j遍历的下标范围小心翼翼。但其实仔细研究后发现，这个递推公式仅仅在j-i>=2的时候生效，因此当i为size-1时，并不会用到size的值，j为0时，i也必然只能等于0，并不会用到j=-1的值

![image-20210730170913545](动态规划.assets/image-20210730170913545.png)

由上面的图我们看到，所有i和j均可放心遍历，dp数组的递推公式在合适的位置才会被使用。

##### [516] 最长回文子序列

给定一个字符串，求其最长回文子序列的长度。

**分析**

此题与前面题目的变化在于，其研究对象不是子字符串，而是子序列。

设定$dp[i][j]$为[i,j]内最长回文子序列的长度。我们可以写出递推公式

```c++
if(s[i]==s[j]){
	if(j-i<=1) dp[i][j] = j-i+1;
	else dp[i][j]=dp[i+1][j-1]+2;
}
else{
	dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
}
```

其他照旧。值得一提的是，最终返回值为$dp[0][size-1]$,这是因为dp数组的定义完全符合题目。

#### 1.2 子数组问题 

##### [53]/剑指 Offer 42. 最大子序和

给定数组nums，元素有正有负，求其最大子数组和，要求时间复杂度为O(n)

**分析**

设定dp[i]是以i为结尾的子数组的最大和，则我们得到递推公式

```c++
dp[i] = max(dp[i-1]+nums[i],nums[i]);
```

**反思**

自己也清楚dp数组应该代表的含义，但是从含义到递推公式这一步却怎么也迈不出。根本原因在于自己没有带入dp[i]的含义去考虑问题。**时刻铭记i是必须存在的，而其他部分是可有可无的，就会清楚递推公式该怎么写了。**

##### [674] 最长连续递增序列

给定数组nums，求其最长连续递增序列的长度。

**分析**

设定dp[i]为以i为结尾的子数组的连续递增长度，则我们可得到递推公式

```
if(nums[i]>nums[i-1])dp[i] = dp[i-1]+1;
else dp[i]=1;
```

由此我们也容易得到dp[0]=1，遍历顺序是从前向后的。



贪心算法在子数组问题中的应用，前面两道题目都可以用贪心算法解决



##### [718] 最长重复子数组

两个整数数组 `A` 和 `B` ，返回两个数组中公共的最长子数组的长度。

**分析**

设$dp[i][j]$的含义为：以i-1为结尾的数组A和j-1为结尾的数组B的最长公共子数组的长度。

两个字符串或者数组的问题一般都可以通过比较尾元素是否相等来进行破局。

```c++
if(A[i-1]==B[j-1]) dp[i][j] = dp[i-1][j-1]+1;
else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
```

由dp数组的含义我们可知$dp[0][0],dp[0][1],dp[1][0]$都需要初始值。

由递推公式，当i=1,j=1且$A[0]==B[0]$时，$dp[1][1] = dp[0][0]+1$，因此$dp[0][0]$应该为0

当i=1,j=1且A[0]!=B[0]时，$dp[1][1]= max(dp[0][1],dp[1][0])$，因此$dp[0][1]$和$dp[1][0]$应该都为0

遍历的顺序:i和j都应该是从前向后的遍历，且起点均为1

```
    1 0 1 0 1 
  0 0 0 0 0 0 
0 0 0 1 1 1 1                  
1 0 1 1 2 2 2 
1 0 1 1 2 2 3 
1 0 1 1 2 2 3 
1 0 1 1 2 2 3 

```



#### 1.3 子序列问题

子序列：可以理解为在数组中选取的元素的组合（但是这个组合的顺序非常重要，关系着某些我们关心的性质）不必连续

连续序列：即子数组问题。

前面我们已经做过很多子数组的问题，但是这里介绍的是有关子序列的题目

##### [300] 最长递增子序列

给定一个数组nums，求其最长递增子序列的长度。

**分析**

设定$dp[i]$​的含义为：以i结尾的子序列，其最长递增子序列的长度。则我们马上得到递推公式

```c++
if(nums[i]>nums[j]) dp[i] = max(dp[i],dp[j]+1);
其中j [0,i) 
```

则我们很容易得知，dp[0]=1,且遍历顺序是从前向后的，i从1开始计算。

##### 9/19 [673] 最长递增子序列的个数

**分析**

这道题目是300题的进阶版，与300题配合食用。



##### [1143] 最长公共子序列

给定两个字符串`text1`和`test2` ，求两个字符串的最长公共子序列。

**分析**

**设定$dp[i][j]$​​​​的含义为：以i为结尾的text1子串和以j为结尾的text2子串，其最长公共子序列的长度。**

==为什么这里含义不设为子序列而设为子串呢？==

如果设为子序列，必然要进行循环遍历，或者说，子序列本身就不适合递推

$dp[i][j]$：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为$dp[i][j]$

涉及到两个序列的题目，思考方向一般是看i和j对应的元素是否相等。

```c++
if(text1[i-1]==text2[i-1]) dp[i][j] = dp[i-1][j-1];
else dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
```

##### [1035] 不相交的线



##### [115] 不同的子序列

给定两个字符串s和t，求在s中出现t的子序列的个数。==换成子数组呢？==

**分析**

dp数组含义的确定原则：

1. 尽量设定为子数组，子字符串，慎重设定为子序列。
2. 可截断性。即截断题目的输入，也能给出同样的条件。因此为了达成此目的，一般完全按照题目含义设置dp数组含义。

例如，在本题中，我们直接设定$dp[i][j]$为以i-1为结尾的s字符串中，出现以j-1为结尾的t的子序列的个数。

```c++
if(s[i-1]==t[j-1]) dp[i][j] = dp[i-1][j]+dp[i-1][j-1];
else dp[i][j] = dp[i-1][j];
```

初始值设定$dp[0][j]$​为0，$dp[0][0]=1$​（只需要设定这些值被使用的场景即可）

#### 1.4 编辑距离问题

这些题目其实从本质上来说也是属于字符串类型的题目。之所以将其列出来是这类题目的递推表达式比较难想，需要一定的套路和技巧。

##### [72] 编辑距离

给定两个字符串`word1`和`word2`，求将`word1`转化成`word2`至少需要几步。你可以插入、删除、替换`word1`中的任意字符。

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```



#### 1.5 数值分配问题

##### 剑指offer14-1 剪绳子

给定长为n的绳子，将其分成m（m>1）份绳子，求子绳子长度乘积的最大值







### 二、股票交易问题

```
dp[i][j]的含义: 在第i天（0-index）处于j状态时能够获得的最大利润
```

##### [121] 买卖股票的最佳时机

只交易一次

##### [122] 买卖股票的最佳时机 II

交易次数不限

##### [123] 买卖股票的最佳时机III

最多两次交易

##### [188] 买卖股票的最佳时机IV

最多k次交易

变体：含冷冻期，含手续费

##### [309] 最佳买卖股票时机含冷冻期

##### [714] 买卖股票的最佳时机含手续费

# 背包问题

### 0. 前言

之所以这样分类原因是我认为组合问题和排列问题思路的出发点完全不同。组合问题的出发点是站在有限范围思考，而组合问题的出发点一定是要站在全局角度思考。因此排列问题通常在思考时试图“忽略i的存在”。

背包问题通常是这样的：给定一个数组，并给定一个“限制”，求其元素组成的组合或者排列的某种性质。

对于问题的分类不能浮于问题表面，而是要深入问题本质，将应用问题转换成上面三种模型，值得一提的是，其实有些问题，可以用不止一种模型来解决，例如416分割等和子集.

### 一、组合问题

- 纯背包问题（<=target的最大值，其实跟=target方法数有某些程度的一致，很多题能用两种方法解决）

```c++
dp[j] = max( dp[j],dp[j-nums[i]]+value[i] );
```

- 和为target方法数

```c++
dp[j]=dp[j]+dp[j-nums[i]];  
//01背包和完全背包遍历顺序不同????
```

- 集合最大最小长度问题

```c++
dp[j] = max(dp[j],dp[j-nums[i]+1]);
dp[j] = min(dp[j],dp[j-nums[i]]+1);
```

true or false 416 139

#### 1.1 不可重复，<=target最大和（纯01背包问题）

##### 416 分割等和子集 



##### 1049最后一块石头的重量② 

给定stones，将stones分成重量最为相近的两堆，求两堆的最小差值

#### 1.2 不可重复，=target方法数

##### 494 目标和 

给定nums和target，求凑成target方法数

##### 416分割等和子集

给定nums，求是否能够将nums分成和相等的两份？

思路1：=sum/2 方法数 不为0，true;为0，false

思路2：<=target 价值 不为target,false;为target，true

#### 1.3 可重复，=target方法数

##### 518 零钱兑换②

给定coins和amount，coins可无限制选取，求凑成amount方法数

#### 1.4 不可重复，<=target组合最大长度

##### 474 1和0

#### 1.5 可重复，=target组合最小长度

##### 322 零钱兑换

给定coins和amount，coins可无限制选取，求凑成amount的最小硬币数量

##### 279 完全平方数

给定n，它为若干个完全平方数的和，求凑成n的完全平方数的最小数量

难点在于由n生成完全平方数的数组

```c++
vector<int> nums;
for(int i=1;i*i<=n;i++){
	nums.push_back(i*i);
}
```

==排列的模糊感从何而来？==



### 二、排列问题

##### 排列问题必须都是可无限制选取的？

##### 排列问题只有=target问题 是有意义的？

##### 排列问题递推表达式

```c++
dp[i][j] = dp[i-1][j] + dp[nums.size()-1][j-nums[i]];
// dp[i][i] = 不放i物品的情况 + 可以放i物品的情况
1. 遍历顺序应该先j再i
2. 每样物品应该无限制选取
dp[j] +=dp[j-nums[i]];

```

#### 2.1 可重复，=target方法数

##### 377 组合总和 

给定nums和target，求凑成target的排列有多少种？

##### 70 爬楼梯

一次只能爬1个或两个台阶，求爬上n节台阶有多少种爬法？

#### 







### Trails

##### 思考框架

1. 确定是一个背包问题
2. 什么类型问题：纯背包？=target方法数 =target方法最长最短 由此写出二维递推表达式
3. 排列 or 组合？二维的遍历顺序？ 压缩成一维的遍历顺序？
4. dp数组初值：自己举个例子假设一下

对于分割问题，dp数组的意义尤为重要。一般是首先确定dp数组的含义，再根据其含义现场推导递推表达式。

##### 代码一般结构：

```c++
dp数组的定义
dp数组的特殊赋值

for循环嵌套与递推公式

return (一般是return dp[target];)
```

##### 什么样的问题是动态规划问题？

==组合 排列 分割字符串/分割数组/分割数值问题/股票交易问题==

前因->后果 前面的选择会导致后面的连锁反应 非列举式问题

##### 什么影响遍历顺序？什么情况下遍历顺序可以交换，什么情况下又不能？

 递推公式影响遍历顺序，准确地说，递推式中左侧元素和右侧元素的位置关系。

什么情况可能改变遍历顺序: 压缩数组空间，从二维到一维

##### 什么会影响倒序？

二维->一维过程中省略的是i还是i-1

##### 三类问题：纯背包问题（将nums分成两堆）=target方法数，=target最长/最短方法 递推公式？注意事项？

注意方法数是否会溢出，尤其是=target方法数问题，元素无限制选取时

```c++
1. 背包问题
2. =target方法数

dp[i][j] = dp[i-1][j]+dp[i-1][j-nums[i]]
3. =target方法的最长/最短值
```

**对于=target方法数问题，更加推荐使用unsigned作为dp数组的元素类型**

有时dp数组的值用int装不下了，根据题意换成范围更大 的数据类型

例如：416分割等和子集中 使用unsigned类型的数组作为dp数组

每个元素不会超过100，数组大小不会超过200，这样数组总和不会超过100*200=20000，int类型完全能够表示吧？本体表示的不是和，而是组合数，因此，当题目属于组合数量这一模型时，一定要留意dp数组能否表示得了最大的组合数。

signed int能够表示的数据范围：-2147483648~2147483647

##### 初始化问题

如何初始化，自己举简单的例子验证递推表达式

##### 



















#### 1. 使用二维数组解决01背包问题和完全背包问题

##### 1.1 怎样初始化？

由01背包问题和完全背包问题在二维数组中的递推公式只能在i>=1时生效，因此对于第一行i=0时的数据，我们需要进行手动初始化。

既然是手动初始化，那其实并没有那么多的条条框框，只需要保证初始值正确即可。方式也有很多。

###### 如何“避免”手动初始化？

但其实还有一种方式，可以避免手动初始化第一行的数据，那就是改变i代表的含义。在默认的体系中，i的含义是“索引”，因此i=0本就是有意义的。如果将i的含义稍作改变为“个数”，那么i=0将变得没有意义，通过给i=0设定合理的初始值，i=1的值完全可以由i=0的值根据递推公式推导而来。

##### 1.2 能否交换遍历顺序？

能否交换遍历顺序只需要关注一个问题，即在递推的时候，（i,j）的值由哪个“方位”的值推导而来。显而易见的，在01背包问题和完全背包问题中，递推所需的值完全是从“左上角”推导而来的，因此交换遍历顺序毫无问题。

需要注意的是，遍历顺序的交换并不会干涉到初始化的位置。也就是说，i为“索引”时，就算交换了遍历顺序，我们仍然需要初始化“i=0”的值，而不是初始化j=0的值。而当i为“个数”时，无需手动初始化，即可完成遍历。

##### 1.3 装满背包的方法

递推公式与纯背包问题不同，初始化方式不同

#### 2. 使用一维数组解决01背包问题和完全背包问题

从一维数组到二维数组，初始化的值保持与二维数组i为“个数”时，i=0的值即可。

##### 2.1 递推公式与遍历顺序

使用一维数组时，需要对递推公式进行修改，在修改的过程中，递推公式的写法需要特定遍历顺序的配合。

##### 2.2 装满背包的方法
