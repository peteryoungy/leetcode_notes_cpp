[TOC]

### 

### 一、二叉树的遍历

==这些题目到底在讨论些什么？有没有什么共性？==

##### 226/剑指 Offer 27. 反转二叉树/二叉树的镜像

给定二叉树root，将二叉树翻转为其镜像并返回根结点

分析：思路很简单，对任意节点，交换其左右节点。

##### 剑指 Offer 32 - I. <u>从上到下打印二叉树</u>

层序遍历打印二叉树的节点值，不打印空节点，返回类型为`vector<int>`

##### 剑指 Offer 32 - II. 从上到下打印二叉树 II

层序遍历打印二叉树的节点值，不打印空节点，返回类型为`vector<vector<int>>`

##### 剑指 Offer 32 - III. 从上到下打印二叉树 III

按之字形打印二叉树。例如，第0层从左向右打印，第1层则从右向左打印，以此类推。返回类型为`vector<vector<int>>`

分析：常规层序遍历使用queue作为数据结构，它具有先进先出的特性，使得二叉树只能按照某个方向打印。

但是如果使用stack，它会具有反向的效果。具体来说，当当前层是从左向右打印时，我们按照（左，右）的顺序添加节点到stack中，则在下一层打印时我们会优先打印最右侧的节点。同理，当当前层是从右向左打印时，我们按照（右，左）的顺序添加节点到stack中，则在下一层打印时我们会优先打印最左侧的节点。

此外，由于使用了stack，如果一直使用一个stack，则会优先pop下一层的节点。解决这个问题的方法是使用两个stack，st0和st1,当使用st0打印节点信息时，将下一层节点添加到st1中，然后再交换。

定义`toRight`变量表示当前层的打印方向。同时，使用st[toRight]表示当前即将使用的stack。具体对应关系查看代码。

##### 101 对称二叉树

给定两棵树root1,root2，判断这两颗树是否是对称二叉树。

宏观描述：以根节点为中心，左右子树镜像对称

数学描述：两棵树是对称二叉树 = 根结点的左右节点值相同 && 左节点的左子树与右节点的右子树镜像对称 && 左节点的右子树与右节点的左子树镜像对称

##### 104. 二叉树的最大深度

##### 111. 二叉树的最小深度

与上题的区别在于max(left,right)得到的一定是从叶子结点出发的路径长度，而 min(left,right)在左右节点的不都存在的情况下，会得到从非叶子结点出发的路径长度。

因此在代码中要根据左右节点是否全都存在的情况，使用不同的表达式返回

##### 222. 完全二叉树的节点个数

```c++
完全二叉树：除了最后一层，其余各层的节点都被填满。而且最后一层的节点集中于左侧部分。

满二叉树：一种特殊的完全二叉树，最后一层都是满的。

二叉搜索树BST：对于每个节点，如果其存在左节点和右节点，必然满足左节点的值<根结点的值<右节点的值
```

平衡二叉搜索树

##### 110. 平衡二叉树

给定二叉树root，判断其是否为平衡二叉树。返回true or false

高度平衡二叉树：对于**每个节点**，其左右两个子树的高度差不会超过1

二叉树的高度 = 二叉树的最大深度

数学描述：若一棵树是平衡二叉树，则它需要满足：其左右两个子树的高度差不超过1，左右两个子树也是平衡二叉树。

##### 404 左叶子之和

左叶子之和 = （如果左节点是叶子结点的话）左节点值 + 以左节点为根的树左叶子之和 + 以右节点为根的树左叶子之和

```c++
return val + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
```

##### 617. 合并二叉树

给定两个个二叉树，将他们两个合并并返回合并后的二叉树。

合并的含义：若两棵树的对应节点都存在，则合并后的节点值为两个节点之和；若仅有一个节点存在，则合并后的结果就是该节点。

##### 513. 找树左下角的值（利用遍历的性质）

给定一个二叉树，求其左下角的值。左下角的值：树的最后一行最左侧的值。

分析：首先思考的问题是如何找左下角的值，或者说这个左下角的节点有什么特点。

我很快发现这个题目必须遍历树的所有节点，也就是说只有遍历到最后才能得到最后答案，那我们知道这符合无返回值遍历的特点。

很快我们又想到：只要遍历顺序是左树比右树先，那么在同一层中肯定最先遍历到最左侧的节点。因此我们的遍历顺序可以是中序遍历，也可以是后序遍历，还可以是前序遍历。**所以真正本质是左树比右树先遍历而不是左树最先遍历。**因为如果根节点有子节点的话，val肯定会被子节点更新。但是只有左树比右树先，才会先访问到同层最左侧的节点。那么，对于求右下角的值，我们也知道了，只需要右树比左树先遍历即可。

想要找到最后一层的最左侧节点，我们只需维护一个最大深度maxDepth，只有在当前深度大于maxDepth时，才更新val的值。因此，当前深度depth是需要我们在遍历中去传递的一个值。

##### 讨论二叉树递归中的代码精简问题

```c++
void traversal(TreeNode* root, int leftLen) {
    if (root->left) {
        leftLen++;
        traversal(root->left, leftLen);
        leftLen--; 
    }
    if (root->right) {
        leftLen++;
        traversal(root->right, leftLen);
        leftLen--; 
    }
}
```

以上这段代码只是一个框架，省略了若干细节。如何对上面的代码进行精简呢？

1. 首先，我们可以尽量避免root子节点有效性的验证，让函数在遍历到空节点时返回即可。==如果是有返回值的函数怎么办?==
2. 对于数值类型变量的回溯，并且是通过递归函数传递的值，我们可以在递归时直接传递改变后的值，无需繁琐的++/--操作。而对于vector类型的回溯（通常是函数外定义的公共变量）我们才有必要push_back()和pop_back()。==所以这里的关键点在于这个变量是在函数外定义的还是作为递归参数定义的？== 在函数外定义的变量，我们才有必要手动回溯；而在递归函数形参中定义的变量，我们只需要在传递时做运算即可（如果可以用表达式表达的话）

精简后的代码如下：

```c++
void traversal(TreeNode* root, int leftLen) {
    if(!root) return;
    
    traversal(root->left, leftLen+1);
    traversal(root->right, leftLen+1);
}
```

可以看到，代码量还是精简了不少，可读性也大大提高。

### 二、二叉搜索树

- 二叉搜索数中允许有重复的值吗？

  默认情况下认为是不允许的。但具体看题目定义。

- 一个重要的性质：二叉搜索树的中序遍历是严格递增的。这个性质在验证BST或利用BST做一些应用时非常有用。**因此，BST相关的题目应该优先考虑中序遍历。**

#### 2.1 BST的性质

##### 700. 二叉搜索树中的搜索

给定一棵二叉搜索树root和一个值val，在树中搜索val。若找到，返回val所在节点，若不存在，返回nullptr。

##### 98. <u>验证二叉搜索树</u>

给定一棵二叉树root，验证其是否为二叉搜索树。

==感觉仍有可以性能优化的空间，例如，只有left为true时才遍历右树。==

##### 530. <u>二叉搜索树的最小绝对差</u>

给定一棵二叉搜索树，求该树任意两个节点的差绝对值的最小值。树中至少有两个节点。

分析：根据BST的性质，中序遍历时，遍历的值是严格递增的。我们可以利用这点，计算相邻节点的差，并保存其最小值。

##### 501. 二叉搜索树中的众数

给定一棵二叉搜索树root

==wait for edit==

##### 538. 把二叉搜索树转换为累加树

给定一棵二叉搜索树root，将其转换为一棵累加树，使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

分析：根据累加树的定义，每个节点的值都为大于等于该节点值的总和。那么如果按照右-根-左的顺序遍历，那么节点的访问顺序是由大到小的。只需要用`pre`保存上个节点中更新后的值，与该节点值进行相加即可。

**98,530,501,538都用到了一个技巧，就是在遍历的时候保存上一个节点的指针pre。**

```c++
TreeNode *pre = nullptr;
void travresal(TreeNode *root){
	
    if(!root) return;
    
    traversal(root->left);
    
    if(pre){

    }
    if(!pre){ // 处理当树只有一个节点的情况
        
    }
    pre = root;
	
    traversal(root->right);
}
```

#### 2.2 在BST中增删节点

##### 701. 二叉搜索树中的插入操作

给定一棵二叉搜索树root和一个待插入值val，将val插入到这颗二叉搜索树中并保持插入后仍是一棵二叉搜索树。返回插入后树的根节点值。

##### 450. 删除二叉搜索树中的节点

给定一棵二叉搜索树root和一个值key，删除key所在的节点并在保持该树仍旧是二叉搜索树的前提下返回该树的根结点。

==如何删除一棵普通树的给定节点？==

##### 669. 修剪二叉搜索树

给定一棵二叉搜索树root和一个范围[low,high]，修剪这颗二叉搜索树使得树中仅留下范围在[low,high]内的节点，返回修剪后的二叉树根结点。





### 二、由一维数组构造二叉树

##### 剑指 Offer 33. 二叉搜索树的后序遍历序列

给定一个一维数组nums，判断其是否为某二叉搜索树的后序遍历结果

##### 106. 从中序与后序遍历序列构造二叉树

##### 105. 从前序与中序遍历序列构造二叉树

根据前序遍历和后序遍历是无法构造二叉树的，我们必须需要中序遍历来帮助我们分开左树与右树的节点值。

```
1. 找到根结点：前序遍历的第一个元素，后序遍历的最后一个元素，并构造出root节点
2. 在中序遍历中找到root的位置index：线性遍历O(n)
3. 以index为左右，构造左树的中序遍历和右树的中序遍历；同时能够根据index，构造左树的前序/后序遍历和右树的前序/后序遍历。（两种情况的中序遍历构造方式一样，前序和后序遍历构造下标有所区别）
4. 递归调用构造左树和右树，同时得到左树的根结点和右树的根结点, return root
```

##### 654. 最大二叉树

给定数组nums，按题目所给定规则构造一棵“最大二叉树”。

##### 108. 将有序数组转换为二叉搜索树

给定严格递增数组nums，将其转化成一个“高度平衡的”二叉搜索树。高度平衡二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

分析：满足高度平衡这个条件，只需要每次都选择数组中点作为根结点即可。其余步骤都非常简单：中点左侧的值用于构建左树，中点右侧的值用于构建右树。

**在构造二叉树的题目中，一个常见的优化手段是：避免重复定义数组**

如果不再向递归函数中传递子数组，那就要传入下标边界，使得当前遍历函数能够确定处理的数组范围。

一个关键性问题是如何计算下标边界，在106和105题中，下标的计算非常容易出错！要仔细考虑！

出错的原因在于：中序遍历的index不能直接等于后序遍历的index

那为什么直接构造子数组的时候不需要做index到postindex的转换呢？

因为我们每次向遍历函数传入的两个数组都是“对齐”过后的数组，因此index可以通用。

### 三、二叉树+回溯

##### 257. 二叉树的所有路径

给定二叉树root，返回一个vector<string>，其中每个string都代表一条从根节点到叶子结点的路径，形如：“1->3->6”

二叉树的回溯：

它假定遍历到哪个node节点，就需要已经有该node的信息在path中，或者说，它的遍历终止条件

它的遍历终止条件与回溯到的节点密切相关。它假设已经含有当前回溯到的节点的信息。

##### 113. 路径总和ii

给定二叉树root和目标值targetSum，求输出所有根结点到叶子结点且路径总和为targetSum的路径。

##### 二叉树的回溯与普通回溯的不同

二叉树的回溯可以理解为每次只有两个选择的普通回溯，在普通回溯中，选择很多，因此我们只能通过for循环来遍历选择的所有可能。但是在二叉树中，每一次的选择不是左子树就是右子树，因此我们可以通过列举的方式遍历。

关键区别在于，遍历到某个节点的时候，path中其实并没有已经保存到这个节点的信息。

解决办法：

- 如同常规做法中所写，在刚进入函数时，直接将节点push到path中，这一步骤甚至比递归终止条件还要早
- 将path初始化为根结点值，后序的代码结构与普通回溯一致。

尽量避免在递归终止条件中进行push和pop

==在二叉树中搜索某个节点并打印其路径==



### TRAILS

#### 容器适配器

C++标准定义了三种容器适配器：stack，queue和priority_queue。其中，stack和queue底层默认用deque实现。priority_queue底层默认用vector实现。stack被定义在<stack>头文件中，后两者被定义在<queue>头文件中。

stack

```c++
a.push(x);
a.pop();
a.top();
a.size();
a.empty();
```

queue

```c++
a.push(x);
a.pop();
a.front();
a.size();
a.empty();
```

#### 层序遍历

层序遍历利用queue实现

##### 边界检查

空树，只有一个根结点的树，两个及两个以上节点的树（一般情况）
