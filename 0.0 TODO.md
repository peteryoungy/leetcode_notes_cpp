







二叉树的递归回溯与普通递归回溯有什么区别？

二叉树如何在遍历时保存上一个节点的指针？

怎样知道一道题可以用递归解答？

递归和循环之间的关系？

动态规划与递归之间的关系？

什么样的题目可以用动态规划解决？

动态规划都有那些模型？

[TOC]



##### 怎样判断一个问题是不是递归的？

基本思想：如果相同的操作被重复调用，那这个方法就可能是递归的。

1. 问题的定义的是递归的

2. 数据结构本身是递归定义的。例如：二叉树，链表
3. 问题的解法是递归的。这个就比较有说法了，这句话的含义类似于问题的解法是迭代的

==对于循环来说，每次执行相同的操作，那是否就说明的能用循环体写的程序就一定可以用递归写出来呢？==

==如果反过来说，能用递归写的程序能否被转换成普通的循环结构呢？==

首先回答第二个问题，我觉得有些递归程序是不能被转换成循环结构的。例如最简单的回溯问题，组合求和。其递归终止条件我们知道是`sum==target`，但是如果把它转换成循环结构，循环的层数是不确定的。也就是说，有可能经过5层循环找到结果，有可能经过10层循环，但也有可能经过10000层循环才找到结果。不知道循环的层数，我们没有办法写出确切的代码。==因此，递归的本质就是循环的嵌套？== ==所以，关键问题在于，递归的层数是否是常数？==

即便递归的次数是常数，这个常数有可能是编译期未知的，作为参数传入，那这个时候我们也没有办法写出确切的代码。还有，如果递归的层数太多，对于程序员来说思路容易混乱，而且代码的可读性也很差。

我们得出结论，在大部分情况下，递归法相对于迭代法来说是简便的。

单层循环与多层循环：究竟是转化成单层还是多层？

如果是单层的话，怎么退出？

递归中，有“退出”这种操作。这是递归特性还是回溯的特性？

多层可以退出，但实现多层

有的问题就是单层，有的问题就是多层，链表问题，就是单层。

那么第一个问题

剑指OFFER62



##### 什么时候遍历函数traversal需要返回值，什么时候又不需要？

https://mp.weixin.qq.com/s/6TWAVjxQ34kVqROWgcRFOg

当我们想知道的结果只有当遍历完全整棵树才能够确定时，遍历函数不需要返回值。

而当我们想知道的结果在遍历中途就可以确定时，这时需要返回值及时return，避免多余的浪费。

在98 验证二叉搜索树中，若遍历途中发现某节点的值小于等于上一个遍历的节点的值时，我们马上就可以断言这棵树一定不是二叉搜索树了，因此就要结束遍历及时返回。

当然我们也可以写出一个不带返回值的函数，当某节点的值小于等于上一个遍历的节点的值时，我们改变一个函数外bool类型变量的值为false（初始化为true）。当遍历结束，该变量仍为true，说明该树为二叉搜索树。

==那我提出一个大胆的假设：所有有返回值的遍历函数均可以用无返回值的函数代替，有返回值只不过是对无返回值的一种性能优化。==

例如 98 验证二叉搜索树 就可以改造成无返回值的遍历。后面如果遇到类似的题目可以再接着考虑	

==无返回值的函数能否全部用有返回值的函数替代？==

感觉并不行。后续可以持续观察。在113路径总和中，题目要求输出所有根-叶节点路径总和为targetSum的路径。为了解决这个问题，必定要遍历树的所有路径。如果给递归函数添加了返回值，这个返回值的意义何在呢？或者说，这个返回值能用来表示什么呢？

两种特殊的返回值：bool和TreeNode/ListNode

==在有些题目中，就算是需要遍历所有的节点才能完成任务，递归函数也拥有者返回值，这一点还是非常的令人费解。==

例如在二叉树的相关题目中，如果

一般而言一个遍历函数是否需要返回值由以下几点因素决定：

1. 题目要求遍历函数的返回类型，有的类型是可拼接的，有的类型明显的不可拼接。

   例如，`bool`,`TreeNode*`，甚至`int`类型都可以看作是可拼接的。如`vector<int>`,`vector<vector<int>>`都是不可拼接的。

   **是否是可拼接的还需要看返回值代表的具体含义。**

   在530 BST的最小绝对差中，题目要求返回int类型，其代表的意义是BST的最小绝对差，从含义上来讲它是可拼接的。

   但是在501众数题目中，要求返回int类型，但是该int类型代表的意义是二叉树中出现频率最大的数，它从含义上来说并不具有拼接性。

   **当返回类型是可拼接时，可以优先考虑使用有返回值的递归函数，但返回类型不可拼接时，只能考虑无返回值的递归函数。**

   ==有返回值的递归函数一定可以被写成无返回值的递归函数吗？==

   研究这个问题的意义何在呢？感觉绝大多数有返回值的递归函数被改写成无返回值的递归函数之后都会显得更加复杂。

   例如TreeNode*类型的函数。

   但是对于530 BST的最小绝对差，写成无返回值的递归函数反而感觉比有返回值的函数更加的简洁和易读。这是因为其返回值的意义代表一个全局最小值。这种“全局含义”的变量很适合作为函数外定义的变量存在。

