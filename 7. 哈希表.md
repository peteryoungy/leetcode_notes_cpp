## HashTable

哈希表在算法题中的作用在于可以保存某些关键信息，降低算法的时间复杂度。也就是我们常说的用空间换取时间。

使用哈希表的题目都有一些小“线索”，提示我们可能要使用哈希法。

```c++
xxx的出现频率
xxx是否出现
字符串仅由小写字母或大写字母构成
```

##### 哈希表的三种形式

数组，set和map

这里面最值得一提的就是数组。数组对比于set和map的优势在于空间消耗更加小，其提供的存储能力相当于一个map。但是数组的使用条件比较苛刻。我们必须保证key的取值范围在一个可预测且密集的范围内。

1. 可预测性：即你提前能够清楚key的范围在[x,y]内
2. 密集型：key不仅要能够预测，而且要足够密集，假设你提前清楚key的取值范围在[1,1000]内，但是可能很多key不存在，这样的情况也会造成数组空间的极大浪费。

数组的一个常用场景是小写字母（当然大写字母也可以，只是小写的比较常见）作为key。

set只能表示元素是否出现，没办法表示出现次数或者更复杂的信息。如果你只需要知道这个元素是否出现过，那就用set就好，但如果你还想同时保存别的信息，就使用map或数组。

##### 各类set和map的特点（尤其注意其查询增删效率）

**set**

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(logn)  | O(logn)  |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

**map**

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(logn)  | O(logn)  |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

##### 接口函数

```C++
find()   //返回查找到的元素的迭代器，若找不到，返回尾迭代器end()
insert()	//插入某元素
erase()		//删除某元素
```

##### map的N种插入方式

```c++
mmap.insert({nums[i],i});
mmap.insert(pair<int,int>(nums[i],i));
mmap.insert(make_pair(nums[i],i));
//前三种插入的思路都是一致的，构建一个pair对象，然后insert，区别只在于构建pair对象的方式不同。
///1.列表初始化，pair是支持这种初始化方式的，因此它支持隐式的类型转换
///2.显式构造
///3. 使用make_pair函数构造
    
mmap[nums[i]] = i;
//这一种就比较特殊了，利用了map的特性，即使key不存在也能通过下标创建（与数组形成对比）
```



#### 数组的使用

##### [242] 有效的字母异位词

若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。给定s和t，判断它们是否互为字母异位词。s和t仅包含小写字母。

**分析**

题目提到了出现的次数。因此很容易想到用map来保存每个字符出现的频率。由于s和t仅包含小写字母，因此直接使用数组更为方便。

##### [383] 赎金信

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

**分析**

这道题与前一道题目的区别在于，字母异位词要求两个字符串每个字符出现的频率完全相等。而本题magazines中字符出现的频率只要>=ransom中字符出现的频率即可。

##### [1002] 查找常用字符

#### set or map

##### [349] 两个数组的交集

给定两个可能含有重复数字的数组nums1,nums2，求两个数组的交集。

**分析**

使用`unordered_set`可以去重复。需要对两个数组去重复吗？不需要。我们首先对nums1去重复得到set1，遍历nums2，对于出现在set1中的数字，直接push到数组中，同时将其在set1中删除，这样防止了nums2的重复数字对结果造成的干扰。

##### [202] 快乐数

**分析**

当需要使用一个整数的每一位时，一个小技巧是将这个整数转换成string类型，这个技巧在==别处==也经常用到。

```c++
for(char c:s){
	int digit = c-'0'; 
}
```

##### [205] 同构字符串

**分析**

思路来源于对同构字符串特点的发掘。

==为什么自己的思路通常都会想麻烦，而答案总是简洁又容易理解？==

 

#### N数之和

##### [1] 两数之和

给定一个整数数组nums，并给定一个target，求返回和为target的两个数的下标。

1. 你可以假设答案一定存在且有且只有一个。
2. 每个元素只能使用一次，但数组中可能存在重复元素。

**分析**

看到nums和target，第一时间想到的是递归+回溯。

递归+回溯的本质是暴力法

==同样用$O(N^2)$​​的时间复杂度实现一个算法，是否迭代法从空间上来说比递归更加节省？==因为有调用栈的开销。

为什么不能用双指针法？如何修改题目就能用了？

双指针法的前提是数组是有序的，但是题目要求返回下标，因此不能进行排序。如果题目要求返回和为target的两个数而不是下标，就可以用双指针法了。



##### [15] 三数之和

给定数组nums，求三数和为0的所有组合。

**分析**

这道题与两数之和的区别在于：

1. 返回的是组合而不是下标，这为双指针法提供了可能。
2. 题目不保证答案的数量，有可能没有答案，也有可能存在多个答案。

为什么不能用哈希法？

##### [18] 四数之和



##### [454] 四数相加 II

给定四个等长数组，在每个数组选取一个元素相加，求其和为0的组合个数。

**分析**

这道题与前面三道题目最大的区别在于选取的元素来自不同的数组而并不是一个数组。其好处就是可以肆无忌惮的使用建立哈希表而不同担心重复的问题。

