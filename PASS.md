##### 7/24 [1736] 替换隐藏数字得到的最晚时间

给定字符串“hh:mm”表示（小时，分钟），取值范围从00:00到23:59。其中含有‘？’，补全该字符串使其表示的时间最晚。

**分析**

该题目的关键点在于发现前两位数字的补全需要互相依靠而不是独立的。而后两位的补全可以完全独立。

==stoi不能用于char类型向int类型的转换！char类型本身可以加减运算，可以利用起来。==

**总结**

这是一道简单题目，基本思路自己当时也大体上想出来了。但也有缺陷。**自己非常慷慨地使用了vector来提升代码的可读性，殊不知这造成了空间上的浪费。**

当然，提升代码的可读性是很重要的一部分，但自己心里要清楚这其中付出的代价，尤其是不必要的代价。对于本就没有什么大必要的内存消耗，能省则省。

##### 7/25 [1743] 从相邻元素对还原数组

给定一组二维邻居数组，复原其原本数组。

```
给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。

题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。
```

##### 分析

最关键的一步是，找到头部元素，然后按顺序找其相邻元素即可完成复原。

但是自己没有使用哈希表保存元素邻居，导致每次寻找都需要遍历二维数组`adjacentPairs`，单次寻找时间复杂度为$O(N)$,总体时间复杂度为$O(N^2)$​。

如果使用map，可以将总体时间复杂度降低为$O(N)$​，因为每次寻找都花费常数时间。付出的代价是$O(N)$​​的空间复杂度，为每个元素保存其邻居。**与单一过大的时间复杂度相比，平均时间与空间的代价是更加友好的。**

**总结**

基本思路自己当时是差不多想出来了，**但是缺陷在于没有使用哈希表保存每个元素的邻居，导致时间复杂度高达$O(N^2)$。**

这反映出自己在思路上的缺陷，总是尽可能地想其他做法来降低时间复杂度，却总是不舍得利用空间复杂度来换取时间复杂度。

给我的启示是，如果以后想要优化时间复杂度，可以考虑下能否通过使用某些数据结构而不是通过改变算法的方式进行优化。

##### 7/28 [863] 二叉树中所有距离为 K 的结点

##### 7/29 [1104] 二叉树寻路

在一棵无限的二叉树中，每个节点都有两个子节点。树按照“之”字型顺序从1开始进行标号，即：奇数行从左向右标记，偶数行从右向左标记。给定一个标号`label`，返回其经过的标号，返回类型为`vector<int>`

**分析**



##### 7/30 [171] Excel表列序号

给定一个字符串，表示Excel表的列名称，求其对应的列序号。

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
输入: columnTitle = "AB"
输出: 28
输入: columnTitle = "ZY"
输出: 701
```

**分析**

理解题意后可发现，题目的本质就是26进制运算，非常简单，扣好细节即可。



##### 9/14 [162] 寻找峰值

给定一个整数数组nums，找到峰值元素并返回其索引。峰值元素是指其值严格大于左右相邻值的元素。

**分析**



##### 9/15 [212] 单词搜索 II

##### 9/16 [36] 有效的数独



分析

##### 9/17 [292] Nim游戏

**分析**

一开始直接就感觉是动态规划的题目，因为看到了爬楼梯问题的一些影子。但是后来发现使用动态规划导致Time Limited，原因是输入参数n的取值特别大，导致dp数组的推导尽管是线性时间，也超时了。

我马上意识到要采取别的办法，而且意识到可能数字之间存在规律。于是打印了一下前50个数字，果然，我发现只有当n为4的倍数时，主角在这个游戏中才会失败。到这里，整个题目的逻辑就很简单了：只要n是4的倍数，返回false，否则，返回true。

**这道题目给我教训是，当使用动态规划法且dp数组的定义特别长时，一定要小心，这道题目很有可能存在超时超内存的风险，可能存在别的解法！**

##### 9/18 [650] 只有两个键的键盘

**分析**

刚开始理解错了题意，以为有两种方式增加文本，一种是复制粘贴，一种是直接写一个A字母。后来我意识到根本不存在第二种添加文本的方式，所有的文本全部只是通过复制粘贴而来。

由于有前面分析的基础，首先我很快得出，对于偶数，其最快的方式是在文本数量达到一半时，复制粘贴。而对于奇数，我的结论得出的就没有那么快了。首先通过几个例子，我发现当文本数量是3,5,7时，我们没有任何的快捷办法，只能通过复制单个字母得到最终结果。因此我这时就在猜想会不会所有的奇数都是这样的。但是举例子举到9时，我就发现不对劲了。9可以在字母数量为3的时候，复制粘贴两次得到。于是我猜想会不会是奇数是质数和合数之间有区别。果然，举了更多的例子我发现，当这个奇数是非质数时，它可以通过分解成a = m * n的形式快速生成文本，其中m是每次复制的个数，n是复制的次数+1。同时为了保证效率最大化，我们会让m尽可能的大，n尽可能的小。因此对于奇数的生成逻辑我们就清楚了。只需要找到其能整除的最小数（除了1），我们就能完成快速复制，否则，我们只能进行单个字母的复制。

##### 9/20 [58] 最后一个单词的长度

**分析**

这道题

##### 9/21 [725] 分割链表

##### 9/22 [326] 3的幂

##### 9/23 [430] 扁平化多级双向链表

**分析**

这类题目首先能够想到的最直接思路就是模拟，看在模拟过程中都需要哪些操作。我很快意识到这可能会递归地调用函数，再精细的思考就是定义递归接口以及处理递归后的事情。

题目比较巧妙的应对了断连接后的连接恢复，使用pnext保存断连接点，只有当pnext和it->next都为空时，整个流程才会结束；否则，就将pnext和it连接起来。

##### 9/24 [583] 两个字符串的删除操作

**分析**

一开始我把这题题目认为是编辑距离类型的题目，但是仔细分析后发现并不是。完全体的编辑距离题目支持三种操作：插入，删除和修改。但是本题只支持删除操作。那么这道题目的本质就变成了**两个字符串的最长公共子序列问题,与[1143]完全相同**。

紧接着是求递推表达式，这一步比较惊险，还是想出来了。

遍历顺序：由递推表达式可得，i和j都是从小到大遍历。

初始化：这里困扰了我很久，主要原因是如何定义`dp[i][j]`,i和j代表的是坐标还是长度。

起初我用坐标，但是初始化出现了问题，我以为是我对`dp[i][j]`的定义出了问题，后来证明是没错的。

然后我采用长度作为坐标，这里比较隐晦的一点是，当使用长度作为i和j所代表的意义时，判断两个字符是否相等用的是`word1[i-1]==word2[j-1]`，这里很容易被忽略。

##### 9/27 [437] 路径总和③ 

**9/29 [223] 矩形面积**

